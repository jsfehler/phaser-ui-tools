<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"bars_bar.js.html":{"id":"bars_bar.js.html","title":"Source: bars/bar.js","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D Source: bars/bar.js /** Base object for all Bar-like Widgets. * @extends Phaser.Group */ export class Bar extends Phaser.Group { /** * @param {number} x - The Bar's x position. * @param {number} y - The Bar's y position. * @param {boolean} vertical - Sets the Bar's alignment as vertical. */ constructor(game, x = 0, y = 0, vertical = false) { super(game); this.game = game; this.x = x; this.y = y; this.vertical = vertical; } /** Determine the distance the bar can scroll over. */ setTrackScrollAreaSize() { if (this.vertical) { this.trackScrollAreaSize = this.track.height - this.vslice; } else { this.trackScrollAreaSize = this.track.width - this.hslice; } } /** Sets position for the bar's non-moving axis. Centers it inside the track. */ centerStaticAxis() { if (this.vertical) { this.bar.x = ( this.track.x + (this.track.width / 2)) - (this.bar.width / 2); } else { this.bar.y = ( this.track.y + (this.track.height / 2)) - (this.bar.height / 2); } } } × Search results Close "},"containers_column.js.html":{"id":"containers_column.js.html","title":"Source: containers/column.js","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D Source: containers/column.js import { Frame } from './frame'; /** Frame that places new child nodes directly under the previous child. * @extends Frame */ export class Column extends Frame { /** * @param {Object} game - Current game instance. * @param {Number} x - The x position of the Frame. * @param {Number} y - The y position of the Frame. * @param {string} bg - The background image to use. */ constructor(game, x = 0, y = 0, bg = 0) { super(game, x, y, bg); this.alignment = Phaser.BOTTOM_CENTER; } } × Search results Close "},"containers_frame.js.html":{"id":"containers_frame.js.html","title":"Source: containers/frame.js","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D Source: containers/frame.js /** Group with a dedicated background image. * @extends Phaser.Group */ export class Frame extends Phaser.Group { /** * @param {Object} game - Current game instance. * @param {Number} x - The x position of the Frame. * @param {Number} y - The y position of the Frame. * @param {string} bg - The background image to use. */ constructor(game, x = 0, y = 0, bg = 0) { super(game); game.add.existing(this); this.x = x; this.y = y; this.game = game; this.bg = bg; // Add background to Frame. if (bg !== null) { const bgSprite = game.add.sprite(0, 0, bg); bgSprite.sendToBack(); bgSprite.alignIn(this, Phaser.TOP_LEFT); } } /** Adds a new object into the Column, then aligns it under the previous object. * @param {Object} node - The sprite to add to the Column. * @param {Number} alignment - The alignment relative to the previous child. * @param {Number} paddingX - The amount of horizontal space between objects. * @param {Number} paddingY - The amount of vertical space between objects. */ addNode(node, align = null, paddingX = 0, paddingY = 0) { const alignment = align || this.alignment; this.add(node); const previousNode = this.children[this.children.length - 2]; if (previousNode !== undefined) { node.alignTo(previousNode, alignment, paddingX, paddingY); } // Reset the positions for the bar's draggable area. if ('enableBarDrag' in node) { node.enableBarDrag(); } } } × Search results Close "},"bars_draggable_bar.js.html":{"id":"bars_draggable_bar.js.html","title":"Source: bars/draggable_bar.js","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D Source: bars/draggable_bar.js import { Bar } from './bar'; /** * Base object for Bars that can be manipulated with a mouse. * @extends Bar */ export class DraggableBar extends Bar { /** If the vertical scrollbar is draggable, * this function is called when the track is clicked. */ verticalTrackClick() { // Don't register mouse clicks on the bar itself. const mouseY = this.game.input.mousePointer.y; if (mouseY &gt; this.bar.y + this.worldPosition.y + this.bar.height) { this.scrollDown(); } else if (mouseY &lt; this.bar.y + this.worldPosition.y) { this.scrollUp(); } } /** If the horizontal scrollbar is draggable, * this function is called when the track is clicked. */ horizontalTrackClick() { const mouseX = this.game.input.mousePointer.x; // Don't register mouse clicks on the bar itself. if (mouseX &gt; this.bar.x + this.bar.width + this.worldPosition.x) { this.scrollRight(); } else if (mouseX &lt; (this.bar.x + this.worldPosition.x)) { this.scrollLeft(); } } /** Allows the bar to scroll when the track is clicked directly. */ enableTrackClick() { let event; this.track.inputEnabled = true; if (this.vertical) { event = this.verticalTrackClick; } else { event = this.horizontalTrackClick; } this.track.events.onInputDown.add(event, this); } /** When called, ensures the bar can be moved. * Must be called once the bar has finished scrolling. */ enableBarInput() { this.trackClicked = false; this.barMoving = false; this.bar.inputEnabled = true; } /** Enables clicking and dragging on the bar. */ enableBarDrag() { this.setDraggableArea(); this.bar.inputEnabled = true; this.bar.input.enableDrag(); if (this.snapping) { this.bar.events.onInputUp.add(this.snapToClosestPosition, this); } this.bar.events.onInputDown.add(this.saveMousePosition, this); this.bar.events.onDragUpdate.add(this.moveContent, this); let draggableArea; if (this.vertical) { this.bar.input.allowHorizontalDrag = false; draggableArea = this.verticalDraggableArea; } else { this.bar.input.allowVerticalDrag = false; draggableArea = this.horizontalDraggableArea; } this.bar.input.boundsRect = new Phaser.Rectangle( draggableArea.x, draggableArea.y, draggableArea.w, draggableArea.h, ); } saveMousePosition(sprite, pointer) { // When the bar is dragged, record where the mouse clicked down. this.mousePointer = { x: pointer.x, y: pointer.y }; } getBarPosition() { const currentValue = this.valueRange.getCurrentValue(); const windowPositionRatio = currentValue / this.windowScrollAreaSize; return this.trackScrollAreaSize * windowPositionRatio; } getMouseDelta() { let oldMousePosition; if (this.vertical) { oldMousePosition = this.mousePointer.y; } else { oldMousePosition = this.mousePointer.x; } // Only difference between clicking the track/using the keyboard vs mouse drag. let newMousePointer; if (this.trackClicked) { newMousePointer = { x: this.bar.x, y: this.bar.y }; } else { const { mousePointer } = this.game.input; newMousePointer = { x: mousePointer.x, y: mousePointer.y }; } let newMousePosition; if (this.vertical) { newMousePosition = newMousePointer.y; } else { newMousePosition = newMousePointer.x; } this.mousePointer = newMousePointer; // Maximum value for the mouse position. Only update when the new position is inside the track. let maxValue; if (this.vertical) { maxValue = this.track.height + this.worldPosition.y; } else { maxValue = this.track.width + this.worldPosition.x; } let mousePositionDelta; if (newMousePosition &lt; maxValue) { mousePositionDelta = oldMousePosition - newMousePosition; } else { mousePositionDelta = 0; } return mousePositionDelta; } /** Creates the tween for moving the bar to a new position. */ addScrollTween(properties) { this.mousePointer = { x: this.bar.x, y: this.bar.y }; this.trackClicked = true; const newTween = this.game.add.tween(this.bar).to( properties, this.tweenParams.duration, this.tweenParams.ease, true, ); this.addScrollTweenEvents(newTween); } /** Called after a scroll tween is added. Adds the necessary events to the tween. */ addScrollTweenEvents(tween) { // Update the values as the bar moves. tween.onUpdateCallback(this.moveContent, this); tween.onComplete.add(this.enableBarInput, this); } /** For Vertical Scrollbars. Scrolls up by one step. */ scrollUp() { // Prevents users from moving the bar while it's moving. if (this.bar.y !== this.track.y &amp;&amp; !this.barMoving) { const testPosition = this.bar.y - this.vslice; let moveToY = null; this.barMoving = true; // Ensure the bar can't move above the track. if (testPosition &lt;= this.track.y) { moveToY = this.minY; } else { moveToY = this.bar.y - this.vslice; } this.addScrollTween({ y: moveToY }); } } /** For Vertical Scrollbars. Scrolls down by one step. */ scrollDown() { if (this.bar.y + this.bar.height !== this.track.y + this.track.height &amp;&amp; !this.barMoving) { const testPosition = this.bar.y + (this.vslice * 2); let moveToY = null; this.barMoving = true; this.bar.inputEnabled = false; // Ensure the bar can't move below the track. if (testPosition &gt;= this.track.y + this.track.height) { moveToY = this.maxY; } else { moveToY = this.bar.y + this.vslice; } this.addScrollTween({ y: moveToY }); } } /** For Horizontal Scrollbars. Scrolls left by one step. */ scrollLeft() { if (this.bar.x !== this.track.x &amp;&amp; !this.barMoving) { const testPosition = this.bar.x - this.hslice; let moveToX = null; this.barMoving = true; this.bar.inputEnabled = false; // Ensure the bar can't move above the track. if (testPosition &lt;= this.track.x) { moveToX = this.minX; } else { moveToX = this.bar.x - this.hslice; } this.addScrollTween({ x: moveToX }); } } /** For Horizontal Scrollbars. Scrolls right by one step. */ scrollRight() { if (this.bar.x + this.bar.width !== this.track.x + this.track.width &amp;&amp; !this.barMoving) { const testPosition = this.bar.x + (this.hslice * 2); let moveToX = null; this.barMoving = true; this.bar.inputEnabled = false; // Ensure the bar can't move below the track. if (testPosition &gt;= this.track.x + this.track.width) { moveToX = this.maxX; } else { moveToX = this.bar.x + this.hslice; } this.addScrollTween({ x: moveToX }); } } /** Called when the scrollbar needs to move the viewport. * Causes the content to move relative to the bar's position on the track. */ moveContent() { const newGripPositionRatio = this.getGripPositionRatio(); const newContentPosition = newGripPositionRatio * this.windowScrollAreaSize; this.valueRange.adjustValue(newContentPosition); this.onMovement.dispatch(this); } } × Search results Close "},"keyboard_group.js.html":{"id":"keyboard_group.js.html","title":"Source: keyboard_group.js","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D Source: keyboard_group.js /** Collection of sprites that can be selected with the keyboard. * When the select key is hit, the sprite that was selected is now connected to the keyboard. */ export class KeyboardGroup { /** * @param {Object} game - Current game instance. * @param {Boolean} vertical - If the selection should be controlled with up/down or left/right arrow keys. * @param {Object} callbackContext - The context for the onPrevious and onNext Signals. */ constructor(game, vertical, callbackContext) { this.game = game; this.vertical = vertical || false; this.callbackContext = callbackContext; this.children = []; this.selected = null; this.idx = 0; this.upKey = this.game.input.keyboard.addKey(Phaser.Keyboard.UP); this.downKey = this.game.input.keyboard.addKey(Phaser.Keyboard.DOWN); this.leftKey = this.game.input.keyboard.addKey(Phaser.Keyboard.LEFT); this.rightKey = this.game.input.keyboard.addKey(Phaser.Keyboard.RIGHT); this.upEvent = this.prevItem; this.downEvent = this.nextItem; /** * Dispatched when the selected child is set from the current child to the previous child. * @property {Phaser.Signal} */ this.onPrevious = new Phaser.Signal(); /** * Dispatched when the selected child is set from the current child to the next child. * @property {Phaser.Signal} */ this.onNext = new Phaser.Signal(); this.activateGroup(); } /** Add a new child to the group * @param {Object} newNode - The sprite to add to the group. */ addNode(newNode) { this.children.push(newNode); // Ensure the first child is already selected when the game loads. this.selected = this.children[0]; // eslint-disable-line prefer-destructuring this.useBar(); } /** Selects the previous child. */ prevItem() { this.idx = this.idx - 1; if (this.idx &lt; 0) { this.idx = this.children.length - 1; } this.selected = this.children[this.idx]; this.useBar(); this.onPrevious.dispatch(this, this.callbackContext); } /** Selects the next child. */ nextItem() { this.idx = (this.idx + 1) % (this.children.length); this.selected = this.children[this.idx]; this.useBar(); this.onNext.dispatch(this, this.callbackContext); } /** * Enables keyboard input for the group. * @private */ activateGroup() { if (this.vertical) { this.upKey.onDown.add(this.upEvent, this); this.downKey.onDown.add(this.downEvent, this); } else { this.leftKey.onDown.add(this.upEvent, this); this.rightKey.onDown.add(this.downEvent, this); } } /** * Enables keyboard input on a child. * @private */ useBar() { if (this.vertical) { this.leftKey.onDown.removeAll(); this.rightKey.onDown.removeAll(); this.leftKey.onDown.add(this.selected.upEvent, this.selected); this.rightKey.onDown.add(this.selected.downEvent, this.selected); } else { this.upKey.onDown.removeAll(); this.downKey.onDown.removeAll(); this.upKey.onDown.add(this.selected.upEvent, this.selected); this.downKey.onDown.add(this.selected.downEvent, this.selected); } } } × Search results Close "},"bars_quantitybar.js.html":{"id":"bars_quantitybar.js.html","title":"Source: bars/quantitybar.js","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D Source: bars/quantitybar.js import { Bar } from './bar'; import { QuantityRange } from './ranges'; /** * Bar that adjusts the size of a static sprite based on a value. * This is done by masking the sprite and then resizing the mask. * @extends Bar */ export class QuantityBar extends Bar { /** * @param {Object} game - Current game instance. * @param {Object} xy - Dictionary with the values for the bar's x and y position. * @param {Object} values - The numerical values for the bar. * @param {boolean} vertical - Determines if the bar should be vertical or horizontal. * @param {boolean} reverse - Determines the direction the bar moves when adjusted. * @param {string} trackImage - The image key to use for the track. * @param {string} barImage - The image key to use for the bar. Will automatically resize to fit. * @param {Object} tweenParams - Object with duration and easing function for the scrolling tween. */ constructor(game, xy, values, vertical, reverse, trackImage, barImage, tweenParams) { super(game, xy.x, xy.y); game.add.existing(this); this.valueRange = new QuantityRange( this, values.startValue, values.maxValue, ); this.vertical = vertical || false; this.reverse = reverse || false; this.trackImage = trackImage; this.barImage = barImage; this.tweenParams = tweenParams || { duration: 300, ease: Phaser.Easing.Quadratic.Out }; // The track is the static area the bar will move along. this.track = this.game.add.sprite(0, 0, this.trackImage); this.add(this.track); // The bar is a static image taking up the width of the track. this.bar = this.game.add.button( 0, 0, this.barImage, this.moveContent, this, 1, 0, ); this.add(this.bar); this.create(); } /** Sets the bar's mask. */ setMask() { if (this.bar.mask !== null) { this.bar.mask.destroy(); this.bar.mask = null; } const mask = this.game.add.graphics(this.maskX, this.maskY); mask.beginFill(0x0000ff); mask.drawRect(0, 0, this.maskW, this.maskH); // mask.endFill(); this.bar.mask = mask; this.add(mask); } getBarPosition() { const windowPositionRatio = this.valueRange.getRatio() / this.windowScrollAreaSize; return this.trackScrollAreaSize * windowPositionRatio; } create() { this.centerStaticAxis(); // Values for the bar's mask. this.maskW = this.bar.width; this.maskH = this.bar.height; this.maskX = this.bar.x; this.maskY = this.bar.y; // Resizes the bar. if (this.vertical) { this.maskH = this.getBarSize(); } else { this.maskW = this.getBarSize(); } if (this.reverse) { if (this.vertical) { this.maskY = this.getBarFraction(); } else { this.maskX = this.getBarFraction(); } } this.setMask(); // Determine the distance the window can scroll over this.windowScrollAreaSize = this.valueRange.maxValue; // Represents one fraction of the track. this.vslice = (this.track.height * this.valueRange.getRatio()); this.hslice = (this.track.width * this.valueRange.getRatio()); this.setTrackScrollAreaSize(); } /** Creates the tween for adjusting the size of the mask. * @param {Object} properties - Values for the tween's movement. */ addScrollTweenMask(properties) { this.game.add.tween(this.bar.mask).to( properties, this.tweenParams.duration, this.tweenParams.ease, true, ); } /** Adjusts the bar by a given value. * @param {number} newValue - The value to adjust the bar by. */ adjustBar(newValue) { this.valueRange.currentValue += newValue; let tween; const barSize = this.getBarSize(); if (this.reverse) { if (this.vertical) { tween = { height: barSize, y: this.getBarFraction() }; } else { tween = { width: barSize, x: this.getBarFraction() }; } } else { if (this.vertical) { tween = { height: barSize }; } else { tween = { width: barSize }; } } this.addScrollTweenMask(tween); } getBarFraction() { let fraction; if (this.vertical) { fraction = this.track.height * this.valueRange.getRatio(); } else { fraction = this.track.width * this.valueRange.getRatio(); } return fraction; } /** Given a ratio between total content size and viewport size, * return an appropriate percentage of the track. */ getBarSize() { let barSize; if (this.reverse) { if (this.vertical) { barSize = this.track.height - this.valueRange.getRatio(); } else { barSize = this.track.width - this.valueRange.getRatio(); } } else { barSize = this.getBarFraction(); } return barSize; } } × Search results Close "},"bars_ranges.js.html":{"id":"bars_ranges.js.html","title":"Source: bars/ranges.js","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D Source: bars/ranges.js /** Used by a QuantityBar to hold the bar's values. */ export class QuantityRange { /** * @param {number} bar - The QuantityBar object that uses the range. * @param {number} startValue - The initial value for the bar. * @param {number} maxValue - The maximum value the bar can have. */ constructor(bar, startValue, maxValue) { this.bar = bar; this.startValue = startValue; this.maxValue = maxValue; this.currentValue = startValue; } /** Returns the current ratio for how large the bar is compared to the track. */ getRatio() { const ratio = this.currentValue / this.maxValue; return ratio; } /** Returns the bar's current value. */ getCurrentValue() { return this.currentValue; } } /** Used by a ValueBar to hold the bar's values. */ export class ValueRange { /** * @param {number} step - The amount the bar is changed by. * @param {number} startValue - The initial value for the bar. * @param {number} maxValue - The maximum value the bar can have. */ constructor(step, startValue, maxValue) { this.step = step; this.startValue = startValue; this.maxValue = maxValue + step; this.ratio = step / maxValue; // The ratio between the step and max can't be greater than 1. // ie: There can't be more steps than the max value. if (this.ratio &gt; 1) { this.ratio = 1; } this.currentValue = startValue; // List of every possible step. Used for snapping into position by the ValueBar. this.steps = []; for (let i = 0; i &lt; this.maxValue; i += step) { this.steps.push(i); } } /** Adjusts the current value for the bar. * @param {number} newValue - The new current value. */ adjustValue(newValue) { this.currentValue = newValue; } /** Returns the bar's current value. */ getCurrentValue() { return this.currentValue; } } /** Used by a Scrollbar to hold the values and adjust a viewport's position. */ export class ViewportRange { /** * @param {Object} viewport - The viewport to adjust. * @param {boolean} vertical - If the viewport is vertical or horizontal. */ constructor(viewport, vertical) { this.viewport = viewport; this.vertical = vertical; if (vertical) { this.step = viewport.area.height; this.maxValue = viewport.height; } else { this.step = viewport.area.width; this.maxValue = viewport.width; } this.ratio = this.step / this.maxValue; // The ratio between the step and max can't be greater than 1. // ie: There can't be more steps than the max value. if (this.ratio &gt; 1) { this.ratio = 1; } } /** Adjusts the viewport's position. */ adjustValue(newValue) { // Set the content's new position. Uses an offset for where the viewport is on screen. if (this.vertical) { this.viewport.y = newValue + this.viewport.area.y; } else { this.viewport.x = newValue + this.viewport.area.x; } this.viewport.disableOutOfBounds( this.viewport.children, this, this.vertical, ); } getCurrentValue() { let currentValue; if (this.vertical) { // y - an offset for where the viewport is on screen. currentValue = this.viewport.y - this.viewport.area.y; } else { currentValue = this.viewport.x - this.viewport.area.x; } return currentValue; } } × Search results Close "},"containers_row.js.html":{"id":"containers_row.js.html","title":"Source: containers/row.js","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D Source: containers/row.js import { Frame } from './frame'; /** Frame that places new child nodes directly next to the previous child. * @extends Frame */ export class Row extends Frame { /** * @param {Object} game - Current game instance. * @param {Number} x - The x position of the Frame. * @param {Number} y - The y position of the Frame. * @param {string} bg - The background image to use. */ constructor(game, x = 0, y = 0, bg = 0) { super(game, x, y, bg); this.alignment = Phaser.RIGHT_CENTER; } } × Search results Close "},"bars_scrollbar.js.html":{"id":"bars_scrollbar.js.html","title":"Source: bars/scrollbar.js","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D Source: bars/scrollbar.js import { DraggableBar } from './draggable_bar'; import { ViewportRange } from './ranges'; /** * A bar that moves along a track. * The bar is resized relative to the size of the track and size of the content to be scrolled. * @extends DraggableBar */ export class Scrollbar extends DraggableBar { /** * @param {Object} game - Current game instance. * @param {Object} content - Anything that you want to move via the scrollbar. * @param {boolean} draggable - Determines if the scrollbar responds to mouse clicks. * @param {boolean} vertical - Determines if the scrollbar should be vertical or horizontal. * @param {string} trackImage - The image key to use for the track. * @param {string} barImage - The image key to use for the bar. Will automatically resize to fit. * @param {Object} tweenParams - Object with duration and easing function for the scrolling tween. */ constructor(game, content, draggable, vertical, trackImage, barImage, tweenParams) { super(game); game.add.existing(this); this.content = content; this.valueRange = new ViewportRange(content, vertical); this.vertical = vertical || false; this.draggable = draggable || false; this.trackImage = trackImage; this.barImage = barImage; // The smallest pixel size allowed for the bar. this.minBarSize = 44; this.tweenParams = tweenParams || { duration: 300, ease: Phaser.Easing.Quadratic.Out }; // Flag switched on when the track is clicked, switched off after the bar movement is finished. this.trackClicked = false; this.barMoving = false; // Records mouse pointer when clicking the bar. this.mousePointer = null; // The track is the static area the bar will move along. this.track = this.game.add.sprite(0, 0, this.trackImage); this.add(this.track); if (this.draggable) { // If the bar is draggable, clicking the track will move the bar up or down. this.enableTrackClick(); } // The bar is the part that moves, controlling the value of the scrollbar. this.bar = this.game.add.button( this.x, this.y, this.barImage, this.moveContent, this, 1, 0, ); this.add(this.bar); this.resizeBar(); this.minY = this.track.y; this.maxY = (this.track.y + this.track.height) - this.bar.height; this.minX = this.track.x; this.maxX = (this.track.x + this.track.width) - this.bar.width; this.create(); /** * Dispatched when the bar is moved. * @property {Phaser.Signal} */ this.onMovement = new Phaser.Signal(); } /** Given a ratio between total content size and viewport size, * resize the bar sprite to the appropriate percentage of the track. */ resizeBar() { let barSize; if (this.vertical) { barSize = this.track.height * this.valueRange.ratio; } else { barSize = this.track.width * this.valueRange.ratio; } // Prevents bar from becoming microscopic. if (barSize &lt; this.minBarSize) { barSize = this.minBarSize; } // Resizes the bar. if (this.vertical) { this.bar.height = barSize; } else { this.bar.width = barSize; } } create() { this.centerStaticAxis(); if (this.draggable) { this.enableBarDrag(); } // Determine the distance the window can scroll over this.windowScrollAreaSize = this.valueRange.maxValue - this.valueRange.step; // Represents one fraction of the track. this.vslice = (this.track.height * this.valueRange.ratio); this.hslice = (this.track.width * this.valueRange.ratio); this.setTrackScrollAreaSize(); // Initial position for the bar. this.mousePointer = { x: this.bar.x, y: this.bar.y }; this.setInitialBarPosition(); } /** Sets the draggable area of the bar. */ setDraggableArea() { this.verticalDraggableArea = { x: this.track.x - ((this.bar.width - this.track.width) / 2), y: this.track.y, w: this.bar.width, h: this.track.height, }; this.horizontalDraggableArea = { x: this.track.x, y: this.track.y - ((this.bar.height - this.track.height) / 2), w: this.track.width, h: this.bar.height, }; } /** Ensure the bar starts off where it should be, according to the bar's logical position. */ setInitialBarPosition() { const gripPositionOnTrack = this.getBarPosition(); // Make sure the bar is physically where it should be. if (this.vertical) { this.bar.y = gripPositionOnTrack + this.track.y; } else { this.bar.x = gripPositionOnTrack + this.track.x; } } getGripPositionRatio() { const gripPositionOnTrack = this.getBarPosition(); const mousePositionDelta = this.getMouseDelta(); let newGripPosition = gripPositionOnTrack + mousePositionDelta; // Don't let the content scroll above or below the track's size if (newGripPosition &gt; 0) { newGripPosition = 0; } else if (newGripPosition &lt;= -this.trackScrollAreaSize) { newGripPosition = -this.trackScrollAreaSize; } // When the scrollbar is at the top or bottom, prevent a mouse movement that // doesn't move the scrollbar from moving the content. if (this.vertical) { if (this.bar.y &lt;= this.track.y) { newGripPosition = 0; } else if (this.bar.y + this.bar.height &gt;= this.track.y + this.track.height) { newGripPosition = -this.trackScrollAreaSize; } } else { if (this.bar.x &lt;= this.track.x) { newGripPosition = 0; } else if (this.bar.x + this.bar.width &gt;= this.track.x + this.track.width) { newGripPosition = -this.trackScrollAreaSize; } } let newGripPositionRatio = newGripPosition / this.trackScrollAreaSize; // If the scrollable area is less than the size of the scrollbar, // the bar and track will be the same size. // In this scenario, a divide by zero occurs. Capture that and turn it into zero. if (Number.isNaN(newGripPositionRatio)) { newGripPositionRatio = 0; } return newGripPositionRatio; } } × Search results Close "},"buttons.js.html":{"id":"buttons.js.html","title":"Source: buttons.js","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D Source: buttons.js /** Sprite with text added as a child. * @extends Phaser.Sprite */ export class textSprite extends Phaser.Sprite { /** * @param {Object} game - Current game instance. * @param {string} image - The image to create a sprite with. * @param {string} label - The text to place on top of the sprite. * @param {Object} style - The style properties to be set on the Text. * @param {number} x - The x coordinate on screen where the textSprite will be placed. * @param {number} y - The y coordinate on screen where the textSprite will be placed. */ constructor(game, image, label, style, x, y) { super(game, x, y, image); game.add.existing(this); this.text = this.game.add.text(0, 0, label, style); this.text.anchor.set(0.5, 0.5); this.addChild(this.text); } } /** Phaser Button with text added as a child. * @extends Phaser.Button */ export class textButton extends Phaser.Button { /** * @param {Object} game - Current game instance. * @param {string} image - The image to create a sprite with. * @param {string} label - The text to place on top of the sprite. * @param {Object} style - The style properties to be set on the Text. * @param {number} x - The x coordinate on screen where the textSprite will be placed. * @param {number} y - The y coordinate on screen where the textSprite will be placed. * @param {Object} callback - Callback to use when the button is clicked. * @param {Object} callbackContext - The context the callback is called in. */ constructor(game, image, label, style, x, y, callback, callbackContext) { super(game, x, y, image, callback, callbackContext); game.add.existing(this); this.text = this.game.add.text(0, 0, label, style); this.text.anchor.set(0.5, 0.5); this.addChild(this.text); } } × Search results Close "},"utils.js.html":{"id":"utils.js.html","title":"Source: utils.js","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D Source: utils.js const utils = {}; /** * A modulo operator that doesn't allow negative numbers. * @param {number} divdend * @param {number} divisor */ utils.modulo = function modulo(dividend, divisor) { return ((((dividend) % divisor) + divisor) % divisor); }; /** * Select an operator action using a string value. */ utils.operators = { '+': function add(a, b) { return a + b; }, '-': function sub(a, b) { return a - b; }, }; export { utils }; × Search results Close "},"bars_valuebar.js.html":{"id":"bars_valuebar.js.html","title":"Source: bars/valuebar.js","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D Source: bars/valuebar.js import { DraggableBar } from './draggable_bar'; import { ValueRange } from './ranges'; /** * Bar that adjusts a number. * This is done by masking the sprite and then resizing the mask. * @extends DraggableBar */ export class ValueBar extends DraggableBar { /** * @param {Object} game - Current game instance. * @param {Object} xy - Dictionary with the values for the bar's x and y position. * @param {Object} values - The numerical values for the bar. * @param {boolean} draggable - Determines if the scrollbar responds to mouse clicks. * @param {boolean} vertical - Determines if the bar should be vertical or horizontal. * @param {string} trackImage - The image key to use for the track. * @param {string} barImage - The image key to use for the bar. Will automatically resize to fit. * @param {Object} tweenParams - Object with duration and easing function for the scrolling tween. */ constructor(game, xy, values, draggable, vertical, trackImage, barImage, tweenParams) { super(game, xy.x, xy.y); game.add.existing(this); this.valueRange = new ValueRange(values.step, values.startValue, values.maxValue); this.vertical = vertical || false; this.draggable = draggable || false; this.trackImage = trackImage; this.barImage = barImage; this.tweenParams = tweenParams || { duration: 300, ease: Phaser.Easing.Quadratic.Out }; // Flag flipped when the track is clicked, switched off after the bar movement is finished. this.trackClicked = false; this.barMoving = false; // Records mouse pointer when clicking the bar. this.mousePointer = null; // The track is the static area the bar will move along. this.track = this.game.add.sprite(0, 0, this.trackImage); this.add(this.track); // If the bar is draggable, clicking the track will move the bar up or down. if (this.draggable) { this.enableTrackClick(); } // The bar is the part that moves, controlling the value of the scrollbar. this.bar = this.game.add.button( this.x, this.y, this.barImage, this.moveContent, this, 1, 0, ); // Add an invisible background. // This ensures the bar can always be entered correctly, no matter where the grip is. this.bg = this.game.add.graphics(0, 0); this.add(this.bg); this.sendToBack(this.bg); this.bg.beginFill(0xff0000, 0); if (this.vertical) { this.bg.drawRect(0, 0 - (this.bar.height / 2), 1, this.track.height + this.bar.height); } else { this.bg.drawRect(0 - (this.bar.width / 2), 0, this.track.width + this.bar.width, 1); } this.bg.endFill(); this.snapping = true; this.add(this.bar); this.minY = this.track.y - (this.bar.height / 2); this.maxY = (this.track.y + this.track.height) - (this.bar.height / 2); this.minX = this.track.x - (this.bar.width / 2); this.maxX = (this.track.x + this.track.width) - (this.bar.width / 2); this.create(); if (this.vertical) { this.upEvent = this.scrollUp; this.downEvent = this.scrollDown; } else { this.upEvent = this.scrollLeft; this.downEvent = this.scrollRight; } /** * Dispatched when the bar is moved. * @property {Phaser.Signal} */ this.onMovement = new Phaser.Signal(); } create() { this.centerStaticAxis(); if (this.draggable) { this.enableBarDrag(); } // Determine the distance the window can scroll over this.windowScrollAreaSize = this.valueRange.maxValue - this.valueRange.step; // Represents one fraction of the track. this.vslice = (this.track.height * this.valueRange.ratio); this.hslice = (this.track.width * this.valueRange.ratio); this.setTrackScrollAreaSize(); // Initial position for the bar. this.mousePointer = { x: this.bar.x, y: this.bar.y }; this.setInitialBarPosition(); } /** Sets the draggable area of the bar. */ setDraggableArea() { this.verticalDraggableArea = { x: this.track.x - ((this.bar.width - this.track.width) / 2), y: this.track.y - (this.bar.height / 2), w: this.bar.width, h: this.track.height + this.bar.height, }; this.horizontalDraggableArea = { x: this.track.x - (this.bar.width / 2), y: this.track.y - ((this.bar.height - this.track.height) / 2), w: this.track.width + this.bar.width, h: this.bar.height, }; } /** Determine the distance the bar can scroll over */ setTrackScrollAreaSize() { if (this.vertical) { this.trackScrollAreaSize = this.track.height; } else { this.trackScrollAreaSize = this.track.width; } } /** Ensure the bar starts off where it should be, according to the bar's logical position. */ setInitialBarPosition() { const gripPositionOnTrack = this.getBarPosition(); // The bar should always be in centered on it's current position. if (this.vertical) { this.bar.y = (gripPositionOnTrack + this.track.y) - (this.bar.height / 2); } else { this.bar.x = (gripPositionOnTrack + this.track.x) - (this.bar.width / 2); } } /** Returns the closest valid value. */ getClosestPosition() { const currentValue = this.valueRange.getCurrentValue(); let diff = Math.abs(currentValue - this.valueRange.steps[0]); let closestPosition = this.valueRange.steps[0]; for (let i = 0; i &lt; this.valueRange.steps.length; i++) { const newdiff = Math.abs(currentValue - this.valueRange.steps[i]); if (newdiff &lt; diff) { diff = newdiff; closestPosition = this.valueRange.steps[i]; } } return closestPosition; } /** On mouse up, forces the value to equal the closest step. */ snapToClosestPosition() { const closestPosition = this.getClosestPosition(); this.valueRange.adjustValue(closestPosition); this.moveContent(); this.setInitialBarPosition(); } /** Called after a scroll tween is added. Adds the necessary events to the tween. */ addScrollTweenEvents(tween) { // Only update the values once the bar has finished moving. tween.onComplete.add(this.moveContent, this); tween.onComplete.add(this.enableBarInput, this); } getGripPositionRatio() { const gripPositionOnTrack = this.getBarPosition(); const mousePositionDelta = this.getMouseDelta(); let newGripPosition = gripPositionOnTrack - mousePositionDelta; // Don't let the content scroll above or below the track's size if (newGripPosition &lt; 0) { newGripPosition = 0; } else if (newGripPosition &gt;= this.trackScrollAreaSize) { newGripPosition = this.trackScrollAreaSize; } // When the scrollbar is at the top or bottom, prevent a mouse movement that // doesn't move the scrollbar from moving the content. if (this.vertical) { if (this.bar.y &lt;= this.track.y) { newGripPosition = 0; } else if (this.bar.y + this.bar.height &gt;= this.track.y + this.track.height) { newGripPosition = this.trackScrollAreaSize; } } else { if (this.bar.x &lt;= this.track.x) { newGripPosition = 0; } else if (this.bar.x + this.bar.width &gt;= this.track.x + this.track.width) { newGripPosition = this.trackScrollAreaSize; } } let newGripPositionRatio = newGripPosition / this.trackScrollAreaSize; // If the scrollable area is less than the size of the scrollbar, // the bar and track will be the same size. // In this scenario, a divide by zero occurs. Capture that and turn it into zero. if (Number.isNaN(newGripPositionRatio)) { newGripPositionRatio = 0; } return newGripPositionRatio; } } × Search results Close "},"wheel3D.js.html":{"id":"wheel3D.js.html","title":"Source: wheel3D.js","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D Source: wheel3D.js import { utils } from './utils'; /** * Represents a single point in a Wheel3D. * @ignore */ class VectorPoint { /** * @ignore * @param {number} x - The point's virtual x location. * @param {number} y - The point's virtual y location. * @param {number} z - The point's virtual z location. * @param {Object} sprite - The sprite associated with this point. * @param {number} position - The point's position on the Wheel3D. */ constructor(x = 0, y = 0, z = 0, sprite = null, position = 0) { this.x = x; this.y = y; this.z = z; this.sprite = sprite; this.position = position; } getSinCosOfAngle(angle) { // eslint-disable-line class-methods-use-this const rad = (angle * Math.PI) / 180; const cosAngle = Math.cos(rad); const sinAngle = Math.sin(rad); return { cosine: cosAngle, sine: sinAngle }; } rotateY(angle) { const angles = this.getSinCosOfAngle(angle); const z = (this.z * angles.cosine) - (this.x * angles.sine); const x = (this.z * angles.sine) + (this.x * angles.cosine); return new VectorPoint(x, this.y, z); } rotateX(angle) { const angles = this.getSinCosOfAngle(angle); const y = (this.y * angles.cosine) - (this.z * angles.sine); const z = (this.y * angles.sine) + (this.z * angles.cosine); return new VectorPoint(this.x, y, z); } rotateZ(angle) { const angles = this.getSinCosOfAngle(angle); const x = (this.x * angles.cosine) - (this.y * angles.sine); const y = (this.x * angles.sine) + (this.y * angles.cosine); return new VectorPoint(x, y, this.z); } /** Rotate the point along the given axis by the given angle. * @param {string} axis - The axis to rotate. * @param {number} angle - The angle to rotate by. */ rotate(axis, angle) { if (axis === 'x') { return this.rotateX(angle); } else if (axis === 'y') { return this.rotateY(angle); } else if (axis === 'z') { return this.rotateZ(angle); } return null; } /** Project the point to the correct physical location on screen. * z axis is not projected, because screens are 2D. */ project(width, height, factor) { const x = (this.x * factor) + width; const y = (-this.y * factor) + height; return new VectorPoint(x, y, this.z); } } /** * A Wheel of sprites where each item's position is projected in 3D space. * The number of points is automatically determined by the number of items. */ export class Wheel3D { /** * @param {Object} game - Reference to current game instance. * @param {array} sprites - List of sprites to use in the wheel. * @param {Number} firstPlace - Determines which position on the wheel is the active one. * @param {Number} zoom - Determines how far to project the points. * @param {String} axis - The axis the wheel3D places items around. * @param {Object} rotations - Axis and angle to rotate the entire wheel after the initial projection. * @param {Object} visibleRange - Determines which items on the wheel should be visible. If none provided, assumes all items should be visible. * @param {Object} tweenParams - Array with the duration and easing function for the movement tween. */ constructor(game, xy, sprites, firstPlace, zoom, axis, rotations, visibleRange, tweenParams) { this.game = game; this.xy = xy; this.sprites = sprites; this.firstPlace = firstPlace; this.zoom = zoom; this.axis = axis; this.rotationAxis = rotations; this.visibleRange = visibleRange || null; this.tweenParams = tweenParams || { duration: 300, ease: Phaser.Easing.Quadratic.Out }; // Signals this.onStart = new Phaser.Signal(); this.onComplete = new Phaser.Signal(); this.onBackComplete = new Phaser.Signal(); this.onForwardComplete = new Phaser.Signal(); // Group to store wheel sprites in, used for zindex sorting. this.group = this.game.add.group(); } activate() { let angle; let radCos; let radSin; let nx; let ny; let nz; this.pointsAmount = this.sprites.length; this.totalPositions = this.pointsAmount - 1; this.rotationAmount = 360 / this.pointsAmount; // Determines which items in the wheel should be visible. if (this.visibleRange !== null) { const allPositions = []; for (let i = 0; i &lt;= this.totalPositions; i++) { allPositions.push(i); } const maxV = allPositions.slice(0, this.visibleRange.max); const minV = allPositions.slice(this.visibleRange.min); this.visiblePositions = maxV.concat(minV); } // Prevents slamming down the move keys. this.moving = false; // Stores the direction the wheel is moving in. this.direction = null; // Set point positions on logical circle. this.wheelItems = []; const radius = 1; const slice = (2 * Math.PI) / this.pointsAmount; // For a vertical wheel, the X axis is -1. Points are laid out on the Y axis (height) and Z axis (depth). The wheel rotates around the X axis. // For a horizontal wheel, the Y Axis is -1. Points are laid out on the X axis (width) and Z axis (depth). The wheel rotates around the Y axis. // For flat circular wheel, the Z Axis is -1. Points are laid out on the X axis (width) and Y axis (height). The wheel rotates around the Z axis. for (let i = 0; i &lt; this.pointsAmount; i++) { // Add sprite to group. this.sprites[i].wheelPosition = i; this.group.add(this.sprites[i]); angle = slice * i; radCos = radius * Math.cos(angle); radSin = radius * Math.sin(angle); if (this.axis === 'x') { nx = -1; ny = radCos; nz = radSin; } else if (this.axis === 'y') { nx = radCos; ny = -1; nz = radSin; } else if (this.axis === 'z') { nx = radCos; ny = radSin; nz = -1; } this.wheelItems.push(new VectorPoint(nx, ny, nz, this.sprites[i], i)); } // Active Point this.active = this.wheelItems[this.firstPlace].sprite; this.project(); } /** Move the wheel backwards. */ moveBack() { if (this.moving === false) { this.moving = true; this.direction = 0; if (this.axis === 'x' || this.axis === 'z') { this.rotationAxis[this.axis] += this.rotationAmount; } else { // y axis needs to go in the opposite direction. this.rotationAxis[this.axis] -= this.rotationAmount; } this.updatePosition('+'); this.project(); this.resetAngle(); } } /** Move the wheel forward. */ moveForward() { if (this.moving === false) { this.moving = true; this.direction = 1; if (this.axis === 'x' || this.axis === 'z') { this.rotationAxis[this.axis] -= this.rotationAmount; } else { // y axis needs to go in the opposite direction. this.rotationAxis[this.axis] += this.rotationAmount; } this.updatePosition('-'); this.project(); this.resetAngle(); } } /** Project every item in the wheel to it's physical location. */ project() { let newTween; // Create a list with the axes, then remove the projected axis. const arr = ['x', 'y', 'z']; const idx = arr.indexOf(this.axis); arr.splice(idx, 1); // We only need to call all this when moving. It doesn't need to be done // every update for (let i = 0; i &lt; this.wheelItems.length; i++) { // Rotate along the projected axis const rotationOne = this.wheelItems[i].rotate( this.axis, this.rotationAxis[this.axis], ); // Rotate the other 2 axes const rotationTwo = rotationOne.rotate(arr[0], this.rotationAxis[arr[0]]); const rotationThree = rotationTwo.rotate(arr[1], this.rotationAxis[arr[1]]); const p = rotationThree.project( this.xy.x, this.xy.y, this.zoom, ); const transformed = this.wheelItems[i].sprite; transformed.lz = p.z; // Ensure active sprite has no scale/alpha changes. if (this.wheelItems[i].position === this.firstPlace) { transformed.alpha = 1.0; this.active = this.wheelItems[i].sprite; } else { if (this.visibleRange !== null) { const includes = this.visiblePosition.includes(this.wheelItems[i].position); // const includes = _.includes( // this.visiblePositions, // this.wheelItems[i].position, // ); if (includes) { transformed.alpha = 1.0; } else { transformed.alpha = 0.0; } } } // Tween to new position newTween = this.game.add.tween(transformed).to( { x: p.x, y: p.y }, this.tweenParams.duration, this.tweenParams.ease, true, ); newTween.onComplete.add(this.enableMoving, this); } // Sort wheelItems by the projection's z axis for correct z-order when drawing. this.group.sort('lz', Phaser.Group.SORT_ASCENDING); // Wheel's signals are dispatched by the tween's. newTween.onStart.add(this.dispatchOnStart, this); newTween.onComplete.add(this.dispatchOnComplete, this); } /** Called after movement starts. */ dispatchOnStart() { this.onStart.dispatch(this); } /** Called after movement is finished. */ dispatchOnComplete() { if (this.direction === 0) { this.onBackComplete.dispatch(this); } else if (this.direction === 1) { this.onForwardComplete.dispatch(this); } this.onComplete.dispatch(this); } /** Once the buttons have finished their move animation, allow them to move again. */ enableMoving() { this.moving = false; } /** Move all the WheelItem's position by 1. */ updatePosition(operator) { for (let i = 0; i &lt; this.wheelItems.length; i++) { const { position } = this.wheelItems[i]; this.wheelItems[i].position = utils.operators[operator](position, 1); const m = utils.modulo(this.wheelItems[i].position, this.pointsAmount); this.wheelItems[i].position = m; this.wheelItems[i].sprite.wheelPosition = m; } } /** Make sure rotation can't go past 360 in either direction. */ resetAngle() { const angle = this.rotationAxis[this.axis]; if (angle === 360 || angle === -360) { this.rotationAxis[this.axis] = 0; } } } × Search results Close "},"containers_viewport.js.html":{"id":"containers_viewport.js.html","title":"Source: containers/viewport.js","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D Source: containers/viewport.js /** * A container with a limited viewable area. Uses a mask to hide children outside of the specified x/y/width/height area. * Content outside the viewport has their input disabled. * @extends Phaser.Group */ export class Viewport extends Phaser.Group { /** * @param {Object} game - Current game instance. * @param {number} x - The x coordinate on screen where the viewport will be placed. * @param {number} y - The y coordinate on screen where the viewport will be placed. * @param {number} width - The width of the viewport. * @param {number} height - The height of the viewport. */ constructor(game, x, y, width, height) { super(game); game.add.existing(this); this.x = x; this.y = y; // Viewport size and position, distinct from the total window size. this.area = { x, y, width, height, }; // Adding the mask attribute to a group hides objects outside the mask. this.mask = this.game.add.graphics(this.area.x, this.area.y); this.mask.beginFill(0x0000ff); this.mask.drawRect(0, 0, width, height); this.mask.endFill(); } /** Adds a new object into the Viewport. */ addNode(node) { this.add(node); } /** Disable input for all objets outside the viewport's visible area. * Recursively checks all the object's children. * @param {Object} children - The objects to disable, if they're outside the viewport. * @param {Object} context - The context the function is run in. * @param {boolean} vertical - If the bounds should be checked horizontally or vertically. */ disableOutOfBounds(children, context, vertical) { let child; let location; let contentLocation; let trueCoords; // Makes sure the recursive function stops when there's no children. if (children !== undefined) { for (let i = 0; i &lt; children.length; i++) { child = children[i]; child.inputEnabled = true; // An object's x/y is relative to it's parent. // The world gives an x/y relative to the whole game. trueCoords = child.world || child; if (vertical) { location = trueCoords.y; contentLocation = context.viewport.area.y; } else { location = trueCoords.x; contentLocation = context.viewport.area.x; } if (location &lt; contentLocation) { child.inputEnabled = false; } this.disableOutOfBounds(child.children, context, vertical); } } } } × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D Classes Classes Bar Column DraggableBar Frame KeyboardGroup QuantityBar QuantityRange Row Scrollbar textButton textSprite ValueBar ValueRange Viewport ViewportRange Wheel3D × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D × Search results Close "},"Bar.html":{"id":"Bar.html","title":"Class: Bar","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D Class: Bar Bar Base object for all Bar-like Widgets. new Bar(x, y, vertical) Parameters: Name Type Default Description x number 0 The Bar's x position. y number 0 The Bar's y position. vertical boolean false Sets the Bar's alignment as vertical. Source: bars/bar.js, line 4 Extends Phaser.Group Methods centerStaticAxis() Sets position for the bar's non-moving axis. Centers it inside the track. Source: bars/bar.js, line 28 setTrackScrollAreaSize() Determine the distance the bar can scroll over. Source: bars/bar.js, line 20 × Search results Close "},"Column.html":{"id":"Column.html","title":"Class: Column","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D Class: Column Column Frame that places new child nodes directly under the previous child. new Column(game, x, y, bg) Parameters: Name Type Default Description game Object Current game instance. x Number 0 The x position of the Frame. y Number 0 The y position of the Frame. bg string 0 The background image to use. Source: containers/column.js, line 7 Extends Frame Methods addNode(node, alignment, paddingX, paddingY) Adds a new object into the Column, then aligns it under the previous object. Parameters: Name Type Description node Object The sprite to add to the Column. alignment Number The alignment relative to the previous child. paddingX Number The amount of horizontal space between objects. paddingY Number The amount of vertical space between objects. Inherited From: Frame#addNode Source: containers/frame.js, line 34 × Search results Close "},"DraggableBar.html":{"id":"DraggableBar.html","title":"Class: DraggableBar","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D Class: DraggableBar DraggableBar Base object for Bars that can be manipulated with a mouse. new DraggableBar() Source: bars/draggable_bar.js, line 7 Extends Bar Methods addScrollTween() Creates the tween for moving the bar to a new position. Source: bars/draggable_bar.js, line 137 addScrollTweenEvents() Called after a scroll tween is added. Adds the necessary events to the tween. Source: bars/draggable_bar.js, line 151 centerStaticAxis() Sets position for the bar's non-moving axis. Centers it inside the track. Inherited From: Bar#centerStaticAxis Source: bars/bar.js, line 28 enableBarDrag() Enables clicking and dragging on the bar. Source: bars/draggable_bar.js, line 56 enableBarInput() When called, ensures the bar can be moved.Must be called once the bar has finished scrolling. Source: bars/draggable_bar.js, line 50 enableTrackClick() Allows the bar to scroll when the track is clicked directly. Source: bars/draggable_bar.js, line 34 horizontalTrackClick() If the horizontal scrollbar is draggable,this function is called when the track is clicked. Source: bars/draggable_bar.js, line 24 moveContent() Called when the scrollbar needs to move the viewport.Causes the content to move relative to the bar's position on the track. Source: bars/draggable_bar.js, line 231 scrollDown() For Vertical Scrollbars. Scrolls down by one step. Source: bars/draggable_bar.js, line 175 scrollLeft() For Horizontal Scrollbars. Scrolls left by one step. Source: bars/draggable_bar.js, line 193 scrollRight() For Horizontal Scrollbars. Scrolls right by one step. Source: bars/draggable_bar.js, line 211 scrollUp() For Vertical Scrollbars. Scrolls up by one step. Source: bars/draggable_bar.js, line 157 setTrackScrollAreaSize() Determine the distance the bar can scroll over. Inherited From: Bar#setTrackScrollAreaSize Source: bars/bar.js, line 20 verticalTrackClick() If the vertical scrollbar is draggable,this function is called when the track is clicked. Source: bars/draggable_bar.js, line 11 × Search results Close "},"Frame.html":{"id":"Frame.html","title":"Class: Frame","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D Class: Frame Frame Group with a dedicated background image. new Frame(game, x, y, bg) Parameters: Name Type Default Description game Object Current game instance. x Number 0 The x position of the Frame. y Number 0 The y position of the Frame. bg string 0 The background image to use. Source: containers/frame.js, line 4 Extends Phaser.Group Methods addNode(node, alignment, paddingX, paddingY) Adds a new object into the Column, then aligns it under the previous object. Parameters: Name Type Description node Object The sprite to add to the Column. alignment Number The alignment relative to the previous child. paddingX Number The amount of horizontal space between objects. paddingY Number The amount of vertical space between objects. Source: containers/frame.js, line 34 × Search results Close "},"KeyboardGroup.html":{"id":"KeyboardGroup.html","title":"Class: KeyboardGroup","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D Class: KeyboardGroup KeyboardGroup Collection of sprites that can be selected with the keyboard.When the select key is hit, the sprite that was selected is now connected to the keyboard. new KeyboardGroup(game, vertical, callbackContext) Parameters: Name Type Description game Object Current game instance. vertical Boolean If the selection should be controlled with up/down or left/right arrow keys. callbackContext Object The context for the onPrevious and onNext Signals. Source: keyboard_group.js, line 4 Members onNext Dispatched when the selected child is set from the current child to the next child. Properties: Type Description Phaser.Signal Source: keyboard_group.js, line 38 onPrevious Dispatched when the selected child is set from the current child to the previous child. Properties: Type Description Phaser.Signal Source: keyboard_group.js, line 32 Methods addNode(newNode) Add a new child to the group Parameters: Name Type Description newNode Object The sprite to add to the group. Source: keyboard_group.js, line 45 nextItem() Selects the next child. Source: keyboard_group.js, line 67 prevItem() Selects the previous child. Source: keyboard_group.js, line 53 × Search results Close "},"QuantityBar.html":{"id":"QuantityBar.html","title":"Class: QuantityBar","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D Class: QuantityBar QuantityBar Bar that adjusts the size of a static sprite based on a value.This is done by masking the sprite and then resizing the mask. new QuantityBar(game, xy, values, vertical, reverse, trackImage, barImage, tweenParams) Parameters: Name Type Description game Object Current game instance. xy Object Dictionary with the values for the bar's x and y position. values Object The numerical values for the bar. vertical boolean Determines if the bar should be vertical or horizontal. reverse boolean Determines the direction the bar moves when adjusted. trackImage string The image key to use for the track. barImage string The image key to use for the bar. Will automatically resize to fit. tweenParams Object Object with duration and easing function for the scrolling tween. Source: bars/quantitybar.js, line 10 Extends Bar Methods addScrollTweenMask(properties) Creates the tween for adjusting the size of the mask. Parameters: Name Type Description properties Object Values for the tween's movement. Source: bars/quantitybar.js, line 115 adjustBar(newValue) Adjusts the bar by a given value. Parameters: Name Type Description newValue number The value to adjust the bar by. Source: bars/quantitybar.js, line 126 centerStaticAxis() Sets position for the bar's non-moving axis. Centers it inside the track. Inherited From: Bar#centerStaticAxis Source: bars/bar.js, line 28 getBarSize() Given a ratio between total content size and viewport size,return an appropriate percentage of the track. Source: bars/quantitybar.js, line 161 setMask() Sets the bar's mask. Source: bars/quantitybar.js, line 58 setTrackScrollAreaSize() Determine the distance the bar can scroll over. Inherited From: Bar#setTrackScrollAreaSize Source: bars/bar.js, line 20 × Search results Close "},"QuantityRange.html":{"id":"QuantityRange.html","title":"Class: QuantityRange","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D Class: QuantityRange QuantityRange Used by a QuantityBar to hold the bar's values. new QuantityRange(bar, startValue, maxValue) Parameters: Name Type Description bar number The QuantityBar object that uses the range. startValue number The initial value for the bar. maxValue number The maximum value the bar can have. Source: bars/ranges.js, line 2 Methods getCurrentValue() Returns the bar's current value. Source: bars/ranges.js, line 21 getRatio() Returns the current ratio for how large the bar is compared to the track. Source: bars/ranges.js, line 16 × Search results Close "},"Row.html":{"id":"Row.html","title":"Class: Row","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D Class: Row Row Frame that places new child nodes directly next to the previous child. new Row(game, x, y, bg) Parameters: Name Type Default Description game Object Current game instance. x Number 0 The x position of the Frame. y Number 0 The y position of the Frame. bg string 0 The background image to use. Source: containers/row.js, line 7 Extends Frame Methods addNode(node, alignment, paddingX, paddingY) Adds a new object into the Column, then aligns it under the previous object. Parameters: Name Type Description node Object The sprite to add to the Column. alignment Number The alignment relative to the previous child. paddingX Number The amount of horizontal space between objects. paddingY Number The amount of vertical space between objects. Inherited From: Frame#addNode Source: containers/frame.js, line 34 × Search results Close "},"Scrollbar.html":{"id":"Scrollbar.html","title":"Class: Scrollbar","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D Class: Scrollbar Scrollbar A bar that moves along a track.The bar is resized relative to the size of the track and size of the content to be scrolled. new Scrollbar(game, content, draggable, vertical, trackImage, barImage, tweenParams) Parameters: Name Type Description game Object Current game instance. content Object Anything that you want to move via the scrollbar. draggable boolean Determines if the scrollbar responds to mouse clicks. vertical boolean Determines if the scrollbar should be vertical or horizontal. trackImage string The image key to use for the track. barImage string The image key to use for the bar. Will automatically resize to fit. tweenParams Object Object with duration and easing function for the scrolling tween. Source: bars/scrollbar.js, line 10 Extends DraggableBar Members onMovement Dispatched when the bar is moved. Properties: Type Description Phaser.Signal Source: bars/scrollbar.js, line 80 Methods addScrollTween() Creates the tween for moving the bar to a new position. Inherited From: DraggableBar#addScrollTween Source: bars/draggable_bar.js, line 137 addScrollTweenEvents() Called after a scroll tween is added. Adds the necessary events to the tween. Inherited From: DraggableBar#addScrollTweenEvents Source: bars/draggable_bar.js, line 151 centerStaticAxis() Sets position for the bar's non-moving axis. Centers it inside the track. Inherited From: Bar#centerStaticAxis Source: bars/bar.js, line 28 enableBarDrag() Enables clicking and dragging on the bar. Inherited From: DraggableBar#enableBarDrag Source: bars/draggable_bar.js, line 56 enableBarInput() When called, ensures the bar can be moved.Must be called once the bar has finished scrolling. Inherited From: DraggableBar#enableBarInput Source: bars/draggable_bar.js, line 50 enableTrackClick() Allows the bar to scroll when the track is clicked directly. Inherited From: DraggableBar#enableTrackClick Source: bars/draggable_bar.js, line 34 horizontalTrackClick() If the horizontal scrollbar is draggable,this function is called when the track is clicked. Inherited From: DraggableBar#horizontalTrackClick Source: bars/draggable_bar.js, line 24 moveContent() Called when the scrollbar needs to move the viewport.Causes the content to move relative to the bar's position on the track. Inherited From: DraggableBar#moveContent Source: bars/draggable_bar.js, line 231 resizeBar() Given a ratio between total content size and viewport size,resize the bar sprite to the appropriate percentage of the track. Source: bars/scrollbar.js, line 85 scrollDown() For Vertical Scrollbars. Scrolls down by one step. Inherited From: DraggableBar#scrollDown Source: bars/draggable_bar.js, line 175 scrollLeft() For Horizontal Scrollbars. Scrolls left by one step. Inherited From: DraggableBar#scrollLeft Source: bars/draggable_bar.js, line 193 scrollRight() For Horizontal Scrollbars. Scrolls right by one step. Inherited From: DraggableBar#scrollRight Source: bars/draggable_bar.js, line 211 scrollUp() For Vertical Scrollbars. Scrolls up by one step. Inherited From: DraggableBar#scrollUp Source: bars/draggable_bar.js, line 157 setDraggableArea() Sets the draggable area of the bar. Source: bars/scrollbar.js, line 127 setInitialBarPosition() Ensure the bar starts off where it should be, according to the bar's logical position. Source: bars/scrollbar.js, line 143 setTrackScrollAreaSize() Determine the distance the bar can scroll over. Inherited From: Bar#setTrackScrollAreaSize Source: bars/bar.js, line 20 verticalTrackClick() If the vertical scrollbar is draggable,this function is called when the track is clicked. Inherited From: DraggableBar#verticalTrackClick Source: bars/draggable_bar.js, line 11 × Search results Close "},"textButton.html":{"id":"textButton.html","title":"Class: textButton","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D Class: textButton textButton Phaser Button with text added as a child. new textButton(game, image, label, style, x, y, callback, callbackContext) Parameters: Name Type Description game Object Current game instance. image string The image to create a sprite with. label string The text to place on top of the sprite. style Object The style properties to be set on the Text. x number The x coordinate on screen where the textSprite will be placed. y number The y coordinate on screen where the textSprite will be placed. callback Object Callback to use when the button is clicked. callbackContext Object The context the callback is called in. Source: buttons.js, line 27 Extends Phaser.Button × Search results Close "},"textSprite.html":{"id":"textSprite.html","title":"Class: textSprite","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D Class: textSprite textSprite Sprite with text added as a child. new textSprite(game, image, label, style, x, y) Parameters: Name Type Description game Object Current game instance. image string The image to create a sprite with. label string The text to place on top of the sprite. style Object The style properties to be set on the Text. x number The x coordinate on screen where the textSprite will be placed. y number The y coordinate on screen where the textSprite will be placed. Source: buttons.js, line 4 Extends Phaser.Sprite × Search results Close "},"ValueBar.html":{"id":"ValueBar.html","title":"Class: ValueBar","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D Class: ValueBar ValueBar Bar that adjusts a number.This is done by masking the sprite and then resizing the mask. new ValueBar(game, xy, values, draggable, vertical, trackImage, barImage, tweenParams) Parameters: Name Type Description game Object Current game instance. xy Object Dictionary with the values for the bar's x and y position. values Object The numerical values for the bar. draggable boolean Determines if the scrollbar responds to mouse clicks. vertical boolean Determines if the bar should be vertical or horizontal. trackImage string The image key to use for the track. barImage string The image key to use for the bar. Will automatically resize to fit. tweenParams Object Object with duration and easing function for the scrolling tween. Source: bars/valuebar.js, line 10 Extends DraggableBar Members onMovement Dispatched when the bar is moved. Properties: Type Description Phaser.Signal Source: bars/valuebar.js, line 98 Methods addScrollTween() Creates the tween for moving the bar to a new position. Inherited From: DraggableBar#addScrollTween Source: bars/draggable_bar.js, line 137 addScrollTweenEvents() Called after a scroll tween is added. Adds the necessary events to the tween. Overrides: DraggableBar#addScrollTweenEvents Source: bars/valuebar.js, line 182 centerStaticAxis() Sets position for the bar's non-moving axis. Centers it inside the track. Inherited From: Bar#centerStaticAxis Source: bars/bar.js, line 28 enableBarDrag() Enables clicking and dragging on the bar. Inherited From: DraggableBar#enableBarDrag Source: bars/draggable_bar.js, line 56 enableBarInput() When called, ensures the bar can be moved.Must be called once the bar has finished scrolling. Inherited From: DraggableBar#enableBarInput Source: bars/draggable_bar.js, line 50 enableTrackClick() Allows the bar to scroll when the track is clicked directly. Inherited From: DraggableBar#enableTrackClick Source: bars/draggable_bar.js, line 34 getClosestPosition() Returns the closest valid value. Source: bars/valuebar.js, line 157 horizontalTrackClick() If the horizontal scrollbar is draggable,this function is called when the track is clicked. Inherited From: DraggableBar#horizontalTrackClick Source: bars/draggable_bar.js, line 24 moveContent() Called when the scrollbar needs to move the viewport.Causes the content to move relative to the bar's position on the track. Inherited From: DraggableBar#moveContent Source: bars/draggable_bar.js, line 231 scrollDown() For Vertical Scrollbars. Scrolls down by one step. Inherited From: DraggableBar#scrollDown Source: bars/draggable_bar.js, line 175 scrollLeft() For Horizontal Scrollbars. Scrolls left by one step. Inherited From: DraggableBar#scrollLeft Source: bars/draggable_bar.js, line 193 scrollRight() For Horizontal Scrollbars. Scrolls right by one step. Inherited From: DraggableBar#scrollRight Source: bars/draggable_bar.js, line 211 scrollUp() For Vertical Scrollbars. Scrolls up by one step. Inherited From: DraggableBar#scrollUp Source: bars/draggable_bar.js, line 157 setDraggableArea() Sets the draggable area of the bar. Source: bars/valuebar.js, line 122 setInitialBarPosition() Ensure the bar starts off where it should be, according to the bar's logical position. Source: bars/valuebar.js, line 146 setTrackScrollAreaSize() Determine the distance the bar can scroll over Overrides: DraggableBar#setTrackScrollAreaSize Source: bars/valuebar.js, line 138 snapToClosestPosition() On mouse up, forces the value to equal the closest step. Source: bars/valuebar.js, line 174 verticalTrackClick() If the vertical scrollbar is draggable,this function is called when the track is clicked. Inherited From: DraggableBar#verticalTrackClick Source: bars/draggable_bar.js, line 11 × Search results Close "},"ValueRange.html":{"id":"ValueRange.html","title":"Class: ValueRange","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D Class: ValueRange ValueRange Used by a ValueBar to hold the bar's values. new ValueRange(step, startValue, maxValue) Parameters: Name Type Description step number The amount the bar is changed by. startValue number The initial value for the bar. maxValue number The maximum value the bar can have. Source: bars/ranges.js, line 28 Methods adjustValue(newValue) Adjusts the current value for the bar. Parameters: Name Type Description newValue number The new current value. Source: bars/ranges.js, line 58 getCurrentValue() Returns the bar's current value. Source: bars/ranges.js, line 62 × Search results Close "},"Viewport.html":{"id":"Viewport.html","title":"Class: Viewport","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D Class: Viewport Viewport A container with a limited viewable area. Uses a mask to hide children outside of the specified x/y/width/height area.Content outside the viewport has their input disabled. new Viewport(game, x, y, width, height) Parameters: Name Type Description game Object Current game instance. x number The x coordinate on screen where the viewport will be placed. y number The y coordinate on screen where the viewport will be placed. width number The width of the viewport. height number The height of the viewport. Source: containers/viewport.js, line 6 Extends Phaser.Group Methods addNode() Adds a new object into the Viewport. Source: containers/viewport.js, line 36 disableOutOfBounds(children, context, vertical) Disable input for all objets outside the viewport's visible area.Recursively checks all the object's children. Parameters: Name Type Description children Object The objects to disable, if they're outside the viewport. context Object The context the function is run in. vertical boolean If the bounds should be checked horizontally or vertically. Source: containers/viewport.js, line 45 × Search results Close "},"ViewportRange.html":{"id":"ViewportRange.html","title":"Class: ViewportRange","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D Class: ViewportRange ViewportRange Used by a Scrollbar to hold the values and adjust a viewport's position. new ViewportRange(viewport, vertical) Parameters: Name Type Description viewport Object The viewport to adjust. vertical boolean If the viewport is vertical or horizontal. Source: bars/ranges.js, line 69 Methods adjustValue() Adjusts the viewport's position. Source: bars/ranges.js, line 95 × Search results Close "},"Wheel3D.html":{"id":"Wheel3D.html","title":"Class: Wheel3D","body":" DocStrap Classes BarColumnDraggableBarFrameKeyboardGroupQuantityBarQuantityRangeRowScrollbartextButtontextSpriteValueBarValueRangeViewportViewportRangeWheel3D Class: Wheel3D Wheel3D A Wheel of sprites where each item's position is projected in 3D space.The number of points is automatically determined by the number of items. new Wheel3D(game, sprites, firstPlace, zoom, axis, rotations, visibleRange, tweenParams) Parameters: Name Type Description game Object Reference to current game instance. sprites array List of sprites to use in the wheel. firstPlace Number Determines which position on the wheel is the active one. zoom Number Determines how far to project the points. axis String The axis the wheel3D places items around. rotations Object Axis and angle to rotate the entire wheel after the initial projection. visibleRange Object Determines which items on the wheel should be visible. If none provided, assumes all items should be visible. tweenParams Object Array with the duration and easing function for the movement tween. Source: wheel3D.js, line 81 Methods dispatchOnComplete() Called after movement is finished. Source: wheel3D.js, line 292 dispatchOnStart() Called after movement starts. Source: wheel3D.js, line 288 enableMoving() Once the buttons have finished their move animation, allow them to move again. Source: wheel3D.js, line 302 moveBack() Move the wheel backwards. Source: wheel3D.js, line 183 moveForward() Move the wheel forward. Source: wheel3D.js, line 201 project() Project every item in the wheel to it's physical location. Source: wheel3D.js, line 219 resetAngle() Make sure rotation can't go past 360 in either direction. Source: wheel3D.js, line 317 updatePosition() Move all the WheelItem's position by 1. Source: wheel3D.js, line 306 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
